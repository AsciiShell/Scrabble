%!TEX TS-program = xelatex

% Шаблон документа LaTeX создан в 2018 году
% Алексеем Подчезерцевым
% В качестве исходных использованы шаблоны
% 	Данилом Фёдоровых (danil@fedorovykh.ru) 
%		https://www.writelatex.com/coursera/latex/5.2.2
%	LaTeX-шаблон для русской кандидатской диссертации и её автореферата.
%		https://github.com/AndreyAkinshin/Russian-Phd-LaTeX-Dissertation-Template

\documentclass[a4paper,14pt]{article}

\input{data/preambular.tex}
\input{data/algo.tex}
\begin{document} % конец преамбулы, начало документа
\input{data/title.tex}
\tableofcontents
\pagebreak
\section{Аннотация}
	Ежедневно люди проводят много времени пытаясь скрасить ожидание, например в транспорте. Игре <<Эрудит>> в этом году исполняется 50 лет. Данная игра расширяет кругозор и словарный запас человека, кроме того позволяет скоротать время в ожидании чего-либо, либо отдохнуть в компании друзей. Кроме того, реализация данного проекта даст навыки командной работы, применения на практике различных алгоритмов. Поэтому мы выбрали данную тему для работы. В качестве результата разработки был получен программный продукт, реализующий необходимые методы для данной игры.

\section*{Annotation}
Every day people spend a lot of time trying to brighten up the expectation, for example in transport. The game <<Scrabble>> this year marks 50 years. This game expands the horizons and vocabulary of a person, in addition allows you to pass the time waiting for something, or relax with friends. In addition, this project will give us skills of teamwork, chance to make various algorithms in practice. So we chose this subject for work. As a result of the development was obtained a software product that implements the necessary methods for the game.

\pagebreak

\section{Введение}
	Наша курсовая работа посвящена разработке игры <<Эрудит>>. Суть игры заключается в том, что игрокам по очереди необходимо выставлять фишки на игровом поле так, чтобы любая последовательность букв образовывала слово.
	
	\subsection{Анализ готовых решений}
	Изначально <<Эрудит>> рассматривалась как настольная игра для нескольких человек, однако в эпоху информационных технологий были разработаны компьютерные варианты, которые позволяют играть нескольким игрокам, преимущественно по сети Интернет. Поэтому наше решение позволит играть одному игроку против компьютерных соперников.
	
	\subsection{Цель и задачи работы}
	\begin{itemize}
		\item \textbf{Разработать компьютерный вариант настольной игры <<Эрудит>>}
		\item Создать возможность играть против одного или нескольких компьютерных соперников
		\item Реализовать методы для хранения словаря, который можно расширять
		\item Программа должна работать стабильно при всех возможных вариантах игры
	\end{itemize}

	\subsection{Анализ используемых средств}
	В качестве основного языка программирования был выбран Python 3. Данный язык ускоряет процесс разработки, имеет дружелюбный синтаксис и богатую стандартную библиотеку, возможности которой можно легко расширить с помощью дополнительных пакетов.
	
	Так как наше приложение предполагает наличие пользовательского интерфейса, был подключен модуль $PyQt5$, который позволяет быстро и легко создавать пользовательские интерфейсы.
	
	Для взаимодействия команды разработчиков использовалась система контроля версий GIT с веб-сервисом GitHub. Данная комбинация позволяет работать над одним и тем же проектом команде разработчиков не уделяя много времени на решение вопросов связанных с редактированием одинаковых файлов, конфликтов разных версий, обменом кодом посредством внешних носителей и другим схожим проблемам.
	
	Для проведения модульных тестов использовалась библиотека $unittest$, которая позволяет легко создать и выполнять тесты.
	
	В качестве среды программирования использовалась $IntelliJ IDEA$, благодаря которой можно работать с многими языками в одной среде, запускать отладку и проверять тесты.
	
	Данные программные средства существенно облегчили работу  и ускорили процесс разработки, что в итоге привело к созданию более мощного решения.
\section{Использованные классы}	
	\subsection{GameConfig}
	Информация о типах клеток на игровом поле, начальное число фишек у игроков, время хода, количество и цена каждой буквы и другие настройки хранятся в данном статичном классе. Это позволяет быстро изменить параметры игры.
	
	\subsection{Point}
	Данный класс содержит информацию о фишке на поле. Основных полей три - сама буква и координаты на поле. Тип определяется и цена буквы, а так же множитель слова автоматически на основе настроек игры класса $GameConfig$.
	
	\subsection{Message}
	С помощью данного класса удобно передавать результат выполнения из функции. Логическая переменная сообщает программе итог работы, а сообщение выводится пользователю для информирования о событии.
	
	\subsection{MatrixResult}
	Класс-структура, которая хранит результат обработки игрового поля и букв, которые хотим на него поставить. Запоминает успех проверки, количество очков, найденные слова или слова с ошибкой, а так же сообщения об ошибке в случае провала.
		
	\subsection{GameDictionary}
	Это небольшой класс, однако он выполняет важные задачи. При его инициализации из файла загружается словари слов русского языка и пользовательский. В процессе работы программы может быть вызван метод $append(self, item)$, который добавит в пользовательский новое слово и сохранит на диске. Кроме того, метод $prepare(self, alphabet)$ подготавливает словарь для компьютерного соперника. Это существенно облегчает его работу, так как сразу исключает те слова, которые никак не могут быть проставлены.
	\subsection{Matrix}
	В классе $Matrix$ осуществляется поиск слов и подсчет стоимости этих слов. Класс $Matrix$ содержит следующие методы: 
	
	\begin {itemize}
		\item$\_\_init\_\_$
		\item $serch$	
		\item $\_prov$
		\item $\_schit$
		\item $reject\_temp$		
		\item $pasteletters$
		\item $\_ChekKoord$
		\item $\_ValidationCheck$	
		\item $ValidationKoord$
	\end {itemize}
	
	Инициализация переменных происходит в функции $\_\_init\_\_$
	
	С основной задачей класса справляется функция $serch$. Для её работы нужны два массива: один с координатами новых точек, другой с новыми буквами. Но, перед тем, как находить слова, необходимо подготовить и проверить матрицу и исходные массивы, за это отвечают функции: $\_ChekKoord$, $pasteletters$ и $ValidationKoord$.
	
	$\_ChekKoord$ преобразует исходные массивы, делается это из-за того, что в процессе составления массивов в них попадает ненужная информация.
	
	$pasteletters$ вставляет данные из массивов в матрицу.
	
	$ValidationKoord$ с помощью рекурсивной функции $\_ValidationCheck$ определяет правильность заполнения матрицы, другими словами, функция проверяет выполнение следующих условий: конструкция из пересекающихся слов должна содержать в себе точку с координатами (7,7) и не должно быть букв, не принадлежащих этой конструкции.
	
	Функция $reject\_temp$ предназначена для работы с классом извне. Она очищает временные переменные.  
	
	Если $ValidationKoord$ возвращает положительный результат, можно начинать поиск слов. Пробегаемся по всей матрице (кроме последней строки и последнего столбца) и для каждой не пустой ячейки запускаем $\_prov$. $\_prov$ распознает начало слова, при положительном результате запускается функция $\_schit$. $\_schit$ проходит до конца слова, параллельно считая стоимость слова.	Полученный результат обрабатывается, и передаются при помощи класса $MatrixResult$.
	
	\subsection{Player}
	Данный класс содержит базовую информацию об игроке: его имя, тип, номер, сложность (для компьютерного соперника) и др. Применяется на этапе подготовки игры, когда игроку не требуется какая-либо функциональность, но важно запомнить его статус
	
	\subsection{TurnStruct}
	Специальная структура для хранения данных о ходе: ставит ли буквы игрок или пропускает ход, какие буквы и куда помещает игрок, какие буквы будут сброшены, сколько очков можно получить за данное действие
	
	\subsection[GamePlayer]{GamePlayer (наследуется от Player)}
	Данный абстрактный класс, кроме хранения информации об игроке, запоминает информацию о текущей игре. Содержит пустышки-методы, которые предупреждают игрока о начале его хода, об завершении хода противника, а так же следит за тем, не вышло ли время хода игрока. Кроме того, в классе есть два метода, отвечающих за ход игрока - $check\_turn(self, turn)$ и $accept\_turn(self, turn)$. Первый проверяет, можно ли выставить данным образом буквы. В случае успеха возвращает найденные слова и очки, которые можно получить за ход. Следующий же применяет те действия, которые были переданы в данный метод, предварительно проверяя их. Возвращает сообщение об успехе выполнения операции.
	
	\subsection[PlayerLocal]{PlayerLocal (наследуется от GamePlayer)}
	Данный класс предназначен для взаимодействия человека с интерфейсом игры. В нем переопределены методы, отвечающие за уведомление игрока о событиях. Они посылают специальный сигнал, с которым в дальнейшем работает пользовательский интерфейс, который в свою очередь отображает сообщение.
	
	\subsection[PlayerBot]{PlayerBot (наследуется от GamePlayer)}
	В данном классе реализованы все методы для взаимодействия компьютерного соперника с движком игры. При создании экземпляра данного класса дополнительно указывается сложность противника, запускается новый поток, который отвечает за работу вычислительной части робота. Как только настанет ход компьютерного соперника, алгоритм начинает перебирать все возможные варианты слов и пытается вставить данное слово на игровое поле. Для этого ищется соответствие каждой буквы на игровом поле. При совпадении, отсутствию конфликтов перекрытия новым словом старого, наличием всех необходимых букв у игрока подсчитываются очки за такой теоретический ход. Действия продолжаются до тех пор, пока не закончатся слова или не останется слишком мало времени. Затем все возможные варианты упорядочиваются по баллам и выбирается тот, порядковый номер которого равен произведению длины массива на уровень сложности робота, после чего выбранный вариант применяется. В случае отсутствия возможности сделать ход, компьютерный соперник пропускает ход, сбрасывая все буквы
	
	\subsection{GameServer}
	Данный класс является ядром игры. При инициализации обрабатывается массив игроков типа $Player$, которые затем преобразуются в дочерние классы класса $GamePlayer$, подготавливается алфавит, игровое поле, запускается новый поток, в котором будут проходить действия игры (дабы не блокировать основной). Дополнительный поток на каждой итерации дает недостающие буквы игроку, приглашает его сделать ход, ожидает завершения и обрабатывает результат: начисляет очки и бонусы, определяет, не завершился ли ход; после чего уведомляет всех о завершении хода.

	
\section{Классы для работы с графическим интерфейсом}
Для работы с графическим интерфейсом было решено использовать библиотеку $PyQt5$. $PyQt5$ один из самых мощных и популярных кросс-платформенной библиотеки GUI.
	\subsection{Fishka}
	Класс $Fishka$ наследуется от класса $QPushButton$ из библиотеки $PyQt5$. Новый класс необходим для упрощения работы с буквами, каждая кнопка, фишка, знает о себе всю необходимую информацию.
	\subsection{GameWindow}
	Данный класс предназначен для интерактивного взаимодействия с пользователем в процессе самой игры.
	
	Класс $GameWindow$ наследуется от класса из библиотеки $PyQt$ $QWidget$.	
	Функция $\_\_init\_\_$  иницилизирует переменные, вычисляет размеры и создает окно.	
	Далее происходит отрисовка фона. Выполняют функции $paintEvent$ и $drawBackground$.
	\begin{figure}[H]
		\centering
		\includegraphics[width=\linewidth]{bigpole.png}
		\caption{задний фон}
	\end{figure}
		
	В функции $initUI$ создаются виджеты кнопок (QPushButton) и виджет изменения строки (QLineEdet), который будет использоваться в качестве консоли.
		
	После ввода текста в консоль и нажатия кнопки "Enter"\ вызывается функция $enter$.
	В зависимости от введенного текста могут выполнится следующие функции: $Help$, $ProverkaKoordinat$,  $lastLetters$,  $ClearChanges$, $SeveChangesForm$, $dobavlenie$, $Drop$.
	
	\begin {itemize}
	\item $Help$ (Help()) - показывает все возможные команды, которые можно выполнить используя консоль
	\item $ProverkaKoordinat$ (ProverkaKoordinat(i, x, y)) - переносит букву с номером i на позицию (x, y), формирует массивы с новыми буквами и их координатами	
	\item $lastLetters$ (lastLetters()) - отрисовывает буквы, которые вносились в матрицу ранее.
	\item $ClearChanges$ (ClearChanges()) - очищает временные переменные, возвращает на места буквы, переставленные на этом ходу.
	\item $SeveChangesForm$ (SeveChangesForm()) - отправляет данные на проверку.
	\item $dobavlenie$ (dobavlenie(words)) - с разрешения пользователя добавляет новые слова в словарь. Пример такого уведомления можно пронаблюдать на рис. \ref{img:dob}.
	\begin{figure}[bhtp]
		\centering
		\includegraphics[width=0.3\linewidth]{dobavlenie.png}
		\caption{запрос на добавление нового слова}
		\label{img:dob}
	\end{figure}
	\item $Drop$ (Drop(dr)) - сбрасывает буквы, номера которых находятся в массиве dr.
	\end {itemize}
	
	Для вывода уведомлений для пользователя использовалась функция $Message$ (Message(text)), коротая при помощи виджета QMessageBox выводит уведомление пользователю.
	\begin{figure}[H]
		\centering
		\includegraphics[scale=1]{myhod.png}
		\caption{уведомление о начале хода}
	\end{figure}
	\begin{figure}[H]
		\centering
		\includegraphics[scale=1]{endhod.png}
		\caption{уведомление о конце хода}
	\end{figure}


\section{Процесс работы программы}
	В данный момент работа программы начинается с запуска игровых модулей. Создается класс $GameServer$, который создает всех необходимых пользователей, с диска загружается словарь, подготавливается необходимый алфавит, после чего создается игровой интерфейс.

	\subsection[Отрисовка интерфейса]{Отрисовка пользовательского интерфейса}
	Отрисовка интерфейса начинается с создания формы, где задаются ее размеры, местоположение на экране. Далее начинается отрисовка заднего фона и игрового поля, при этом местоположение каждого элемента на поле запоминается.
		
	\subsection{Игровая механика}
	Игроки ходят по очереди, действия компьютерного соперника выполняются автоматически, без вмешательства пользователя. Человеку предоставлена возможность вносить команды через консоль, с помощью которой он может устанавливать позицию фишек, очищать поле, сбрасывать фишки и завершать ход. Затем программа проверяет действия пользователя, и если она не нашла некоторые слова в своем словаре, то спрашивает игрока является ли найденная последовательность букв словом. В случае успеха действия игрока запоминается и ход передается следующему. После каждого хода показывается уведомление, а так же при наступлении очереди текущего игрока. На рис. \ref{img:game} показан промежуточный этап игры.
	
	\begin{figure}[bhtp]
		\centering
		\includegraphics[width=0.5\linewidth]{game.png}
		\caption{Результат модульного тестирования}
		\label{img:game}
	\end{figure}

	\subsection{Завершение игры}
	При достижении условий окончания игры - закончились фишки или все игроки пропустили ход определенное число раз - сервер завершает свою работу и показывает сообщение о баллах, которые набрал каждый игрок.
	
	\begin{figure}[bhtp]
		\centering
		\includegraphics{gameresult.png}
		\caption{Итог игры}\label{img:gameresult}
	\end{figure}
\section{Тестирование}
	Процесс разработки большого коллективного проекта достаточно сложный. Легко допустить ошибку, найти причину которой, а порой и заметить эффект, достаточно сложно. Поэтому были созданы специальные модульные тесты, проверяющие работу некоторых функций, тестировать которые в ручную было бы утомительно.
	
	\subsection{Словарь}
	Был подготовлен случайным образом небольшой словарь, выборку из которого не сложно произвести один раз вручную. Затем на ее основе были созданы данные тесты
	
	Список слов: биосфера, блюз, дворянство, домолачивание, заковывание, изъян, киноведение, колеровщик, координированность, митраизм, налавливание, неминуемость, одухотворенность, окраина, плавсостав, поборник, подхват, приматывание, пролысина, сипловатость, солододробилка, топаз, трином, трехсотлетие, умывание, хранилище, централизация, шейх.
	\begin{table}[!h]
		\begin{center}
		\begin{flushleft}
			\tablecaption{Тестирование словаря}			
		\end{flushleft}
		
		\begin{tabular}{|c|c|}
			\hline
			         Входные данные          & Контрольное значение \\ \hline
			АБВГДЕЖЗИЙКЛМНОПРСТУФХЦЧШЩЪЫЬЭЮЯ &    Длина словаря     \\ \hline
			               А                 &          0           \\ \hline
			              БЛЮЗ               &          1           \\ \hline
			АБВГДЕЖЗИЙКЛМНОПРСТУФХЦЧШЩЪЫЬЭЮ  &  Длина словаря - 3   \\ \hline
		\end{tabular}
		\end{center}
	\end{table}

	\subsection{Фишка}
	Проставление точки на поле так же легко проверить. Для этого сравнивалось контрольное значение типа точки с тем, которое получила при инициализации. На вход подается координаты и буква, на выходе закодированный номер типа.
	
	\begin{table}[!h]
		\begin{center}
			\tablecaption{Тестирование фишки на игровом поле}
			\begin{tabular}{|c|c|}
				\hline
				Входные данные          & Контрольное значение \\ \hline
				0 0 Я& 4 \\ \hline
				6 8 Я& 1 \\ \hline
				4 4 Я& 2 \\ \hline
				1 5 Я& 3 \\ \hline
				1 2 Я& 0 \\ \hline
			\end{tabular}
		\end{center}
	\end{table}

	\subsection{Компьютерный противник}
	При разработке алгоритмов робота часто возникали проблемы, при котором компьютер решал задачу слишком долго или вовсе не находил решение. Полностью проверить ход на верность затруднительно, однако можно легко узнать, выполняет какие-либо действия алгоритм или нет. Для этого были созданы 2 робота, играющие друг против друга. Успехом считалось, что каждый робот наберет некоторое число очков за небольшое время после старта.
	
	\subsection{Обработка результатов}
	\begin{figure}[bhtp]
		\centering		
		\includegraphics[scale=0.8]{unittests.png}
		\caption{Результат модульного тестирования}\label{img:tests}
	\end{figure}
	
	На рис. \ref{img:tests} показан результат успешного тестирования. Нет ни одного с ошибкой, показано игровое поле, которое заполнили два компьютерных соперника, играющие друг против друга.
	
	Однако, это не единственный этап тестирования. В случае успеха на данном этапе выполняется ручное тестирование. Программа должна запуститься, успешно и правильно обрабатывать команды пользователя, выводить результат, компьютерный соперник должен совершать некоторые ходы.
	
\section{Вывод}
	Мы добились поставленной цели. У нас есть компьютерная версия игры <<Эрудит>>, в которой можно играть против нескольких компьютерных соперников. В игре есть возможность добавление новых слов в словарь. В ходе многочисленных тестов программа работала стабильно.
\end{document} % конец документа

