%!TEX TS-program = xelatex

% Шаблон документа LaTeX создан в 2018 году
% Алексеем Подчезерцевым
% В качестве исходных использованы шаблоны
% 	Данилом Фёдоровых (danil@fedorovykh.ru) 
%		https://www.writelatex.com/coursera/latex/5.2.2
%	LaTeX-шаблон для русской кандидатской диссертации и её автореферата.
%		https://github.com/AndreyAkinshin/Russian-Phd-LaTeX-Dissertation-Template

\documentclass[a4paper,14pt]{article}

\input{data/preambular.tex}
\input{data/algo.tex}
\begin{document} % конец преамбулы, начало документа
\input{data/title.tex}
\tableofcontents
\pagebreak
\section{Аннотация}
	Разрабатываем игрушку
	\pagebreak

\section{Использованные классы}
	\subsection{Matrix}
	В классе $Matrix$ осуществляется поиск слов и подсчет стоимости этих слов. Класс $Matrix$ содержит следующие методы: 
	
	\begin {itemize}
		\item$\_\_init\_\_$
		\item $serch$	
		
		\item $\_prov$
		\item $\_schit$
		\item $reject\_temp$
		
		\item $pasteletters$
		\item $\_ChekKoord$
		\item $\_ValidationCheck$	
		\item $ValidationKoord$
	\end {itemize}
	
	Инициализация переменных происходит в функции $\_\_init\_\_$
	
	С основной задачей класса справляется функция $serch$. Для её работы нужны два массива: один с координатами новых точек, другой с новыми буквами. Но, перед тем, как находить слова, необходимо подготовить и проверить матрицу и исходные массивы, за это отвечают функции: $\_ChekKoord$, $pasteletters$ и $ValidationKoord$.
	
	$\_ChekKoord$ преобразует исходные массивы, делается это из-за того, что в процессе составления массивов в них попадает ненужная информация.
	
	$pasteletters$ вставляет данные из массивов в матрицу.
	
	$ValidationKoord$ с помощью рекурсивной функции $\_ValidationCheck$ определяет правильность заполнения матрицы, другими словами, функция проверяет выполнение следующих условий: конструкция из пересекающихся слов должна содержать в себе точку с координатами (7,7) и не должно быть букв, не принадлежащих этой конструкции.
	
	Функция $reject\_temp$ предназначена для работы с классом извне. Она очищает временные переменные.  
	
	Если $ValidationKoord$ возвращает положительный результат, можно начинать поиск слов. Пробегаемся по всей матрице (кроме последней строки и последнего столбца) и для каждой не пустой ячейки запускаем $\_prov$. $\_prov$ распознает начало слова, при положительном результате запускается функция $\_schit$. $\_schit$ проходит до конца слова, параллельно считая стоимость слова.
	
	Полученный результат обрабатывается, и передаются при помощи класса $MatrixResult$.
	
	\subsection{MatrixResult}
	Данный класс предназначен для обработки результата метода $serch$ из класса $Matrix$. $MatrixResult$ состоит всего из одной функции $\_\_init\_\_$, в которой происходит преобразование полученных данных в более удобный формат. 
	
	\subsection{Player}
	Данный класс содержит базовую информацию об игроке: его имя, тип, номер, сложность (для компьютерного соперника) и др. Применяется на этапе подготовки игры, когда игроку не требуется какая-либо функциональность, но важно запомнить его статус
	
	\subsection{TurnStruct}
	Специальная структура для хранения данных о ходе: ставит ли буквы игрок или пропускает ход, какие буквы и куда помещает игрок, какие буквы будут сброшены, сколько очков можно получить за данное действие
	
	\subsection[GamePlayer]{GamePlayer (наследуется от Player)}
	Данный абстрактный класс, кроме хранения информации об игроке, запоминает информацию о текущей игре. Содержит пустышки-методы, которые предупреждают игрока о начале его хода, об завершении хода противника, а так же следит за тем, не вышло ли время хода игрока. Кроме того, в классе есть два метода, отвечающих за ход игрока - $check\_turn(self, turn)$ и $accept\_turn(self, turn)$. Первый проверяет, можно ли выставить данным образом буквы. В случае успеха возвращает найденные слова и очки, которые можно получить за ход. Следующий же применяет те действия, которые были переданы в данный метод, предварительно проверяя их. Возвращает сообщение об успехе выполнения операции.
	
	\subsection[PlayerLocal]{PlayerLocal (наследуется от GamePlayer)}
	Данный класс предназначен для взаимодействия человека с интерфейсом игры. В нем переопределены методы, отвечающие за уведомление игрока о событиях. Они посылают специальный сигнал, с которым в дальнейшем работает пользовательский интерфейс, который в свою очередь отображает сообщение.
	
	\subsection[PlayerBot]{PlayerBot (наследуется от GamePlayer)}
	В данном классе реализованы все методы для взаимодействия компьютерного соперника с движком игры. При создании экземпляра данного класса дополнительно указывается сложность противника, запускается новый поток, который отвечает за работу вычислительной части робота. Как только настанет ход компьютерного соперника, алгоритм начинает перебирать все возможные варианты слов и пытается вставить данное слово на игровое поле. Для этого ищется соответствие каждой буквы на игровом поле. При совпадении, отсутствию конфликтов перекрытия новым словом старого, наличием всех необходимых букв у игрока подсчитываются очки за такой теоретический ход. Действия продолжаются до тех пор, пока не закончатся слова или не останется слишком мало времени. Затем все возможные варианты упорядочиваются по баллам и выбирается тот, порядковый номер которого равен произведению длины массива на уровень сложности робота, после чего выбранный вариант применяется. В случае отсутствия возможности сделать ход, компьютерный соперник пропускает ход, сбрасывая все буквы
	
	\subsection{GameServer}
	Данный класс является ядром игры. При инициализации обрабатывается массив игроков типа $Player$, которые затем преобразуются в дочерние классы класса $GamePlayer$, подготавливается алфавит, игровое поле, запускается новый поток, в котором будут проходить действия игры (дабы не блокировать основной). Дополнительный поток на каждой итерации дает недостающие буквы игроку, приглашает его сделать ход, ожидает завершения и обрабатывает результат: начисляет очки и бонусы, определяет, не завершился ли ход; после чего уведомляет всех о завершении хода.
	
	\subsection{GameConfig}
	Информация о типах клеток на игровом поле, начальное число фишек у игроков, время хода, количество и цена каждой буквы и другие настройки хранятся в данном статичном классе. Это позволяет быстро изменить параметры игры.
	
	\subsection{Point}
	Данный класс содержит информацию о фишке на поле. Основных полей три - сама буква и координаты на поле. Тип определяется и цена буквы, а так же множитель слова автоматически на основе настроек игры класса $GameConfig$.
	
	\subsection{Message}
	С помощью данного класса удобно передавать результат выполнения из функции. Логическая переменная сообщает программе итог работы, а сообщение выводится пользователю для информирования о событии.
	
	\subsection{MatrixResult}
	Класс-структура, которая хранит результат обработки игрового поля и букв, которые хотим на него поставить. Запоминает успех проверки, количество очков, найденные слова или слова с ошибкой, а так же сообщения об ошибке в случае провала.
	
	\subsection{GameDictionary}
	Это небольшой класс, однако он выполняет важные задачи. При его инициализации из файла загружается словари слов русского языка и пользовательский. В процессе работы программы может быть вызван метод $append(self, item)$, который добавит в пользовательский новое слово и сохранит на диске. Кроме того, метод $prepare(self, alphabet)$ подготавливает словарь для компьютерного соперника. Это существенно облегчает его работу, так как сразу исключает те слова, которые никак не могут быть проставлены.
	
\section{Тестирование}
	Процесс разработки большого коллективного проекта достаточно сложный. Легко допустить ошибку, найти причину которой, а порой и заметить эффект, достаточно сложно. Поэтому были созданы специальные модульные тесты, проверяющие работу некоторых функций, тестировать которые в ручную было бы утомительно.
	
	\subsection{Словарь}
	Был подготовлен случайным образом небольшой словарь, выборку из которого не сложно произвести один раз вручную. Затем на ее основе были созданы данные тесты
	
	Список слов: биосфера, блюз, дворянство, домолачивание, заковывание, изъян, киноведение, колеровщик, координированность, митраизм, налавливание, неминуемость, одухотворенность, окраина, плавсостав, поборник, подхват, приматывание, пролысина, сипловатость, солододробилка, топаз, трином, трехсотлетие, умывание, хранилище, централизация, шейх.
	\begin{table}[!h]
		\begin{center}
		\caption{Тестирование словаря}
		\begin{tabular}{|c|c|}
			\hline
			         Входные данные          & Контрольное значение \\ \hline
			АБВГДЕЖЗИЙКЛМНОПРСТУФХЦЧШЩЪЫЬЭЮЯ &    Длина словаря     \\ \hline
			               А                 &          0           \\ \hline
			              БЛЮЗ               &          1           \\ \hline
			АБВГДЕЖЗИЙКЛМНОПРСТУФХЦЧШЩЪЫЬЭЮ  &  Длина словаря - 3   \\ \hline
		\end{tabular}
		\end{center}
	\end{table}

	\subsection{Фишка}
	Проставление точки на поле так же легко проверить. Для этого сравнивалось контрольное значение типа точки с тем, которое получила при инициализации. На вход подается координаты и буква, на выходе закодированный номер типа.
	
	\begin{table}[!h]
		\begin{center}
			\caption{Тестирование фишки на игровом поле}
			\begin{tabular}{|c|c|}
				\hline
				Входные данные          & Контрольное значение \\ \hline
				0 0 Я& 4 \\ \hline
				6 8 Я& 1 \\ \hline
				4 4 Я& 2 \\ \hline
				1 5 Я& 3 \\ \hline
				1 2 Я& 0 \\ \hline
			\end{tabular}
		\end{center}
	\end{table}

	\subsection{Комьютерный противник}
	При разработке алгоритмов робота часто возникали проблемы, при котором компьютер решал задачу слишком долго или вовсе не находил решение. Полностью проверить ход на верность затруднительно, однако можно легко узнать, выполняет какие-либо действия алгоритм или нет. Для этого были созданы 2 робота, играющие друг против друга. Успехом считалось, что каждый робот наберет некоторое число очков за небольшое время после старта
\end{document} % конец документа

