%!TEX TS-program = xelatex

% Шаблон документа LaTeX создан в 2018 году
% Алексеем Подчезерцевым
% В качестве исходных использованы шаблоны
% 	Данилом Фёдоровых (danil@fedorovykh.ru) 
%		https://www.writelatex.com/coursera/latex/5.2.2
%	LaTeX-шаблон для русской кандидатской диссертации и её автореферата.
%		https://github.com/AndreyAkinshin/Russian-Phd-LaTeX-Dissertation-Template

\documentclass[a4paper,14pt]{article}

\input{data/preambular.tex}
\input{data/algo.tex}
\begin{document} % конец преамбулы, начало документа
\input{data/title.tex}
\tableofcontents
\pagebreak
\section{Аннотация}
	Разрабатываем игрушку
	\pagebreak
\section{Словарь игры}
	\subsection{Условие задачи}
	Дан исходный массив слов и набор букв, которые уже есть на поле и у игрока. Необходимо выбрать из исходного списка слов такие, которые теоретически можно составить из данных букв
	\subsection{Постановка задачи}
	\underline{Дано:}
	
	$Words[0:n-1]$ - строки
	
	$Letters[0:m-1]$ - символьные
	
	\underline{Результат:}
	
	$NewWords[0:k-1]$ - строки
	
	\underline{При:}
	
	$n \ge 1, 1 \le m \le 32$
	
	\underline{Связь:}
	
	$k = n, NewWords[0:k-1] = Words[0:n-1]$, если $m = 32$ 
	
	$i=\overline{0, k-1}$
	
	$j=\overline{0, n-1}$
	
	$NewWords[i] = Words[j]$, если $\forall Words[j][e], \exists C, C \in Letters и Words[j][e] = C $
	
	\subsection{Внешняя спецификация}
	Данная функция не предусматривает взаимодействие программы с пользователем
	\pagebreak
	\subsection{Описание алгоритмов}	
	\begin{algorithm*}[!htp]
	\caption{Подготовка словаря}
	\begin{algorithmic}
		\State $k := 0$
		\For{$i:=0$ \textbf{\underline{до}} $n-1$}
			\State $flag := true$
			\State $j := 0$
			\While{$j<\text{длина}(Words[i])$ \textbf{\underline{и}} $flag$} 
				\If{$Words[i][j] \in Letters$}
					\State $j := j + 1$
				\Else
					\State $flag := false$
				\EndIf				
			\EndWhile
			\If{$flag$}
				\State $NewWords[k] := Words[i]$
				\State $k := k + 1$
			\EndIf
		\EndFor
	\end{algorithmic}
	\end{algorithm*}
	\subsection{Тесты}
	Тестовый словарь:
	
	биосфера блюз дворянство домолачивание заковывание изъян киноведение колеровщик координированность митраизм налавливание неминуемость одухотворенность окраина плавсостав поборник подхват приматывание пролысина сипловатость солододробилка топаз трином трехсотлетие умывание хранилище централизация шейх 

	Тесты обрабатывают тестовый словарь и проверяют длину итогового массива
	
	\begin{tabular}{|c|c|}
		\hline
		         Входные данные          & Контрольное значение \\ \hline
		АБВГДЕЖЗИЙКЛМНОПРСТУФХЦЧШЩЪЫЬЭЮЯ &    Длина словаря     \\ \hline
		               А                 &          0           \\ \hline
		              БЛЮЗ               &          1           \\ \hline
		АБВГДЕЖЗИЙКЛМНОПРСТУФХЦЧШЩЪЫЬЭЮ  &  Длина словаря - 3   \\ \hline
	\end{tabular}
	
\section{Использованные классы}
	\subsection{Matrix}
	В классе $Matrix$ осуществляется поиск слов и подсчет стоимости этих слов. Класс $Matrix$ содержит следующие методы: 
	
	\begin {itemize}
		\item$\_\_init\_\_$
		\item $serch$	
		
		\item $\_prov$
		\item $\_schit$
		\item $reject\_temp$
		
		\item $pasteletters$
		\item $\_ChekKoord$
		\item $\_ValidationCheck$	
		\item $ValidationKoord$
	\end {itemize}
	
	Инициализация переменных происходит в функции $\_\_init\_\_$
	
	С основной задачей класса справляется функция $serch$. Для её работы нужны два массива: один с координатами новых точек, другой с новыми буквами. Но, перед тем, как находить слова, необходимо подготовить и проверить матрицу и исходные массивы, за это отвечают функции: $\_ChekKoord$, $pasteletters$ и $ValidationKoord$.
	
	$\_ChekKoord$ преобразует исходные массивы, делается это из-за того, что в процессе составления массивов в них попадает ненужная информация.
	
	$pasteletters$ вставляет данные из массивов в матрицу.
	
	$ValidationKoord$ с помощью рекурсивной функции $\_ValidationCheck$ определяет правильность заполнения матрицы, другими словами, функция проверяет выполнение следующих условий: конструкция из пересекающихся слов должна содержать в себе точку с координатами (7,7) и не должно быть букв, не принадлежащих этой конструкции.
	
	Функция $reject\_temp$ предназначена для работы с классом извне. Она очищает временные переменные.  
	
	Если $ValidationKoord$ возвращает положительный результат, можно начинать поиск слов. Пробегаемся по всей матрице (кроме последней строки и последнего столбца) и для каждой не пустой ячейки запускаем $\_prov$. $\_prov$ распознает начало слова, при положительном результате запускается функция $\_schit$. $\_schit$ проходит до конца слова, параллельно считая стоимость слова.
	
	Полученный результат обрабатывается, и передаются при помощи класса $MatrixResult$.
	
	\subsection{MatrixResult}
	Данный класс предназначен для обработки результата метода $serch$ из класса $Matrix$. $MatrixResult$ состоит всего из одной функции $\_\_init\_\_$, в которой происходит преобразование полученных данных в более удобный формат. 
\end{document} % конец документа

